// Темы:
// Простое наследование. Виртуальные функции. Абстрактные классы.
// Битовые поля.


#include <tchar.h>
#include  "Shape.h"
#include  "myRect.h"
#include "Circle.h"
#include "Bin.h"
#include "Oct.h"
#include "Hex.h"
#include <iostream>

#define	  stop __asm nop

union MyByte
{
private:
	Bin bin;
	Hex hex;
	Oct oct;
	unsigned char ch;

public:
	MyByte(unsigned char _ch)
	{
		ch = _ch;
	}
	void ShowBin()
	{
		bin.Show();
	}
	void ShowHex()
	{
		hex.Show();
	}
	void ShowOct()
	{
		oct.Show();
	}

	void ShowPosBin(int pos)
	{
		bin.ShowPos(pos);
	}

	void EditBin(int pos, int value)
	{
		bin.Edit(pos, value);
	}

	void ShowPosHex(int pos)
	{
		hex.ShowPos(pos);
	}

	void EditHex(int pos, int value)
	{
		hex.Edit(pos, value);
	}

	void ShowOct(int pos)
	{
		oct.ShowPos(pos);
	}

	void EditOct(int pos, int value)
	{
		oct.Edit(pos, value);
	}

	void ShowDec() const
	{
		std::cout << "Dec = "<< static_cast<int> (ch) << std::endl;
	}

	void ShowChar() const
	{
		std::cout<< "Char = " << ch << std::endl;
	}
};

int _tmain(int argc, _TCHAR* argv[])
{

/*
	//Задание 1.Простое наследование.Аргументы конструктора,
	// передаваемые в базовый класс.

	//Создайте иерархию классов:
	//базовый класс Shape (который описывает любую фигуру)
	//и два производных класса Rect и Circle.
	//Подумайте: какие данные и методы нужно ввести в базовый
	//и производные классы (например, любую фигуру можно сделать
	//цветной => в базовом классе можно ввести переменную, которая
	//будет определять цвет фигуры.
	//Подсказка: для хранения цвета объявите перечисление (RED,GREEN,BLUE...);
	
	//В конструкторах производных классов предусмотрите передачу
	//параметра-цвета конструктору базового класса.
	//При создании и уничтожении объекта производного типа определите
	//последовательность вызовов конструкторов и деструкторов базового
	//и производного классов
	{
		Rect rect;
	}


	stop
//////////////////////////////////////////////////////////////////////

	//Задание 2.Виртуальные функции.
	//2а) Модифицируйте классы Shape,Rect и Circle:
	//добавьте в каждый класс public метод void WhereAmI().
	//Реализация каждой функции должна выводить сообщение 
	//следующего вида "Now I am in class Shape(Rect или Circle)".
	//Выполните приведенный фрагмент, объясните результат.


	//2б) Сделайте метод WhereAmI() виртуальным.
	//Снова выполните приведенный фрагмент, объясните разницу.

	{
		Shape s(Blue);
		Rect r;
		Circle c;

	
		//Метод какого класса вызывается в следующих строчках???
		s.WhereAmI();	//	Будет выполнятся метод класса Shape
		r.WhereAmI();	//	Будет выполнятся метод класса Rect
		c.WhereAmI();	//	Будет выполнятся метод класса Circle
		stop


		Shape* pShape = &s;
		Shape* pRect = &r;
		Shape* pCircle = &c;
    	pShape->WhereAmI();	 //	Будет выполнятся метод класса Shape
		pRect->WhereAmI();	 //	Будет выполнятся метод класса Rect, если будет virtual
		pCircle->WhereAmI(); //	Будет выполнятся метод класса Circle, если будет virtual
		stop


		//Заполните ... согласно комментариям
		Shape& rShape = s; //псевдоним s
		Shape& rRect = r; //псевдоним r
		Shape& rCircle = c; //псевдоним c
		rShape.WhereAmI();	//вызов посредством rShape	Будет выполнятся метод класса Shape
		rRect.WhereAmI();	//вызов посредством	rRect	Будет выполнятся метод класса Rect, если будет virtual
		rCircle.WhereAmI(); //вызов посредством rCircle	Будет выполнятся метод класса Circle, если будет virtual

	stop
	}


//////////////////////////////////////////////////////////////////////

	//Задание 3.Виртуальные деструкторы.
	//Модифицируйте классы:
	//a) введите соответствующие
	// деструкторы (без ключевого слова virtual).
	//Реализация каждого деструктора
	//должна выводить сообщение следующего вида
	// "Now I am in Shape's destructor!" или
	// "Now I am in Rect's destructor!"
	//Выполните фрагмент. Объясните результат.
	{
		Rect r;
	}//Будет вызван деструктор класса Rect, потом будет вызван деструктор класса Shape

	// b) Добавьте в объявление деструкторов ключевое слово virtual 
	//Выполните фрагмент.Объясните разницу.

	//Будет вызван деструктор класса Rect, потом будет вызван деструктор класса Shape
	
	//Подумайте: какие конструкторы вызываются в следующей строке?
		//Если в разработанных классов каких-то конструкторов
		//не хватает - реализуйте
		//Если Вы считаете, что в приведенном фрагменте чего-то
		//не хватает - добавьте

		Rect r(1,2,3,4, Blue);

		//Создать конструктор в Круге который принимает прямоугольникЫ
		Shape* ar[]={new Shape(r), new Rect(r), new Circle(r), new Circle() };
		//Вызовите для каждого элемента массива метод WhereAmI()
		for (int i = 0; i < sizeof(ar)/sizeof(Shape*); i++)
		{
			ar[i]->WhereAmI();
		}

	stop
		for (int i = 0; i < sizeof(ar) / sizeof(Shape*); i++)
		{
			delete ar[i];
		}



	//Задание 4*. В чем заключается отличие 1) и 2)
	{
		Shape* pShapes = new Rect[10];//1) Если у класса Rect будет какой-то метод, которого нет у Shape, то его не возможно будет вызвать
		Rect* pRects = new Rect[10];//2)
		

		//Попробуйте вызвать метод WhereAmI() для каждого элемента обоих массивов -
		//в чем заключается проблема???
		for (int i = 0; i < 10; i++)
		{
			pShapes[i].WhereAmI();
			Shape r123 = pShapes[2];
			pRects[i].WhereAmI();
		}


		//Освободите динамически захваченную память
		delete [] pRects;
		delete [] pShapes;

	}



//////////////////////////////////////////////////////////////////////

	//Задание 5.Виртуальные функции и оператор разрешения области видимости. 

	{
		Rect r12(1,2,3,4, Green);
		Shape* p = &r12;	
		p->WhereAmI();//вызовется метод класса Rect
		stop


			//4a Оператор разрешения области видимости.
			//Посредством объекта r и указателя p вызовите виртуальную функцию
			//WhereAmI()класса Shape
			p->Shape::WhereAmI();
			r12.Shape::WhereAmI();
			stop
		
	}


//////////////////////////////////////////////////////////////////////

	//Задание 6.Чисто виртуальные функции. 
	//Введите в базовый класс метод void Inflate(int); Подумайте:
	//можно ли реализовать такой метод для базового класса? => как его нужно объявить.
	//Реализуйте этот метод для производных классов.
	{
		Rect r12(1,2,3,4, Red);
		Shape* p = &r12;
		p->Inflate(5);
		Circle c(2,3,12.5, Blue);
		p = &c;
		p->Inflate(5);
	}

	*/
//////////////////////////////////////////////////////////////////////

	//Задание 7.Объединения (union) C++. Битовые поля.
	//1.
	//Создайте следующие классы для различных представлений значений байта:
	//Bin - для двоичного представления
	//Hex - для шестнадцатерчного представления
	//Oct - для восьмеричного представления.
	//Подсказка 1: - для удобства используйте битовые поля.
	//Подсказка 2: - конструкторов в таких вспомогательных классах быть не должно,
	//так как все они будут членами объединения (union).
	//2.
	//В каждом классе введите метод Show, который должен выводить значение в
	//соответствующем виде
	//3.
	//Посредством объединения MyByte предоставьте пользователю возможность манипулировать
	//одним и тем же значением по-разному:
	//а) выводить: десятичное, шестнадцатеричное, восьмеричное, двоичное значение байта 
	//          а также символ, соответствующий хранимому значению (если есть соответствие);
	//б) выводить отдельные (указанные посредством параметра) шестнадцатеричные,
	//			восьмеричные, двоичные цифры;
	//в) изменять отдельные двоичные, восьмеричные или шестнадцатеричные цифры;


	{
		
	}
	MyByte byte(0x1f);
	byte.ShowHex();
	byte.ShowBin();
	byte.ShowOct();

	byte.ShowChar();
	byte.ShowDec();

	byte.ShowPosBin(5);
	byte.EditBin(3,1);

	byte.ShowPosHex(0);
	byte.EditHex(0, 0xd);

	byte.ShowOct(2);
	byte.EditOct(1, 7);


	stop
	//...


	


	
	return 0;
}//endmain

