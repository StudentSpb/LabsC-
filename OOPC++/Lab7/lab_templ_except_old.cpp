//Исключения

//Шаблоны: 
	//		шаблоны функций,
	//		шаблоны классов,


//#include <tchar.h>


#define stop __asm nop
#include <tchar.h>

int _tmain(int argc, _TCHAR* argv[])
{
	

/*
////////////////////////////////////////////////////////////////////////////
	//Тема. Шаблоны функций.
	//Создайте шаблон функции перестановки местами двух
	//значений - Swap(). Проверьте работоспособность созданного
	//шаблона с помощью приведенного ниже фрагмента кода.
	//Подсказка 1: объявление шаблона корректнее поместить в .h-файл.

	int iX = 1, iY = -1;
	Swap(iX, iY);

	double dX = 0.5, dY = -5.5;
	Swap(dX, dY);

	//Point pt1(1,2), pt2(-3,-4);
	//Swap(pt1, pt2);

	//Подсказка 2: подумайте, что нужно реализовать, для того,
	//			чтобы следующий вызов работал с объектами MyString
	//			не только корректно, но и эффективно
//	MyString str1("One"), str2("Two");
//	Swap(str1, str2);

*/
/////////////////////////////////////////////////////////////////////
	
	//Тема. Шаблоны классов.
	//Задание 1.
	//Создайте шаблон класса MyStack для хранения элементов любого типа T.
	//Подсказка: 1.элементы нужно где-то хранить - простым и удобным средством
	//			для хранения последовательно расположенных в памяти элементов
	//			является массив, 
	//			2.для задания максимального размера стека может быть использован
	//			параметр-константа шаблона
	//			3.обязательными операциями со стеком являются "push" и "pop". Для
	//			того, чтобы гарантировать корректное выполнение этих операций 
	//			хорошо было бы генерировать исключение в аварийной ситуации

	
	//С помощью шаблона MyStack создайте стек из 5 элементов int - iStack и
	//стек из 10 элементов Point - ptStack и поэкспериментируйте с функциями
	//push() и pop()


//	try{
/*
	MyStack< int, 5 > iStack;
	MyStack< Point, 10 > ptStack;
	

		iStack.push(1);
		iStack.push(2);
		iStack.push(3);
		iStack.push(4);
		iStack.push(5);
//	iStack.push(6);	//выход за границы стека

		ptStack.push(Point(1,1));
		ptStack.push(Point(2,2));
*/
/*
	//Добавьте в шаблон стека возможность обращения к элементам
	//по индексу. Для этого переопределите оператор [] таким
	//образом, чтобы он возвращал значение n -ого элемента или генерировал
	//исключение, если требуемый элемент находится вне "корректного"
	//диапазона.
	//Проверьте работоспособность оператора, раскомментировав
	//следующий фрагмент
	iStack[4] = 33;
	Point pt = ptStack[0];
	stop
	ptStack[9] = pt;
//	pt = ptStack[5];
	stop
*/
//	}//end try





	//Задание 2. Реализуйте шаблон стека - MyStack2 таким образом, чтобы 
	//для хранения элементов использовался ОДНОСВЯЗНЫЙ список.



	//Задание 3. Реализуйте шаблон очереди - MyQueue таким образом, чтобы 
	//для хранения элементов использовался динамический массив элементов
	//обобщенного типа. 
	//Буфер должен быть кольцевым, то есть если "хвост" заполнен, но
	//освободились элементы в начале, следует продрлжать заполнение с
	//начала очереди

	return 0;
}

